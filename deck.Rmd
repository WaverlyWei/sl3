---
title: "The `sl3` R Package"
subtitle: "Modern Super Learning with Pipelines"
author: "[Jeremy Coyle](https://github.com/jeremyrcoyle), [Nima
  Hejazi](https://nimahejazi.org), [Ivana
  Malenica](https://github.com/podTockom), [Oleg
  Sofrygin](https://github.com/osofr)"
date: "`r lubridate::now()`"
output:
  xaringan::moon_reader:
    lib_dir: libs
    chakra: libs/remark-latest.min.js
    css: ["default", "custom.css"]
    nature:
      highlightStyle: zenburn
      highlightLines: true
---

```{r knitr_setup, echo=FALSE, message=FALSE}
knitr::opts_chunk$set(fig.width = 7, fig.height = 4.5, dpi = 300,
                      fig.cap = "", fig.align = "center")
showtext::showtext.opts(dpi = 300)
```

# Accessing these slides

--

### View them online:

* [https://www.stat.berkeley.edu/~nhejazi/present/2017_sl3_intro/deck.html](https://www.stat.berkeley.edu/~nhejazi/present/2017_sl3_intro/deck.html)

* here's a shortened URL: [https://goo.gl/bqP2tD](https://goo.gl/bqP2tD)

--

### View them locally:

_You'll need to clone the project branch containing the source materials for
this talk from GitHub. This includes the finalized slide deck (in HTML)._

```{bash, eval=FALSE}
git clone -b talk https://github.com/jeremyrcoyle/sl3.git
```

???

- This talk will focus on introducing the new `sl3` R package, which provides a
modern implementation of the Super Learner algorithm [@vdl2007super], a method
for performing stacked regressions [@breiman1996stacked], combined with
covariate screening and cross-validation.

---
class: inverse, center, middle

# Core `sl3` Design Principles

---

# `sl3` Architecture

All of the classes defined in `sl3` are based on the R6 framework, which brings
a newer object-oriented paradigm to the R language.

## Core classes

- `sl3_Task`, for defining a machine learning problem. These objects keep track
  of the task data, as well as what variables play what roles in the machine
  learning problem. These are easily created by `make_sl3_Task`.

--

- `Lrnr_base`, a base class for defining machine learning algorithms, as well as
  _fits_ for those algorithms to particular `sl3_Task`s. Different learning
  algorithms are defined in classes that inherit from this base class.

--

- `Pipeline`, a set of learners to be fit _sequentially_, where the fit from one
  learner is used to define the task for the next learner. These are a special
  kind of learner derived from `Lrnr_base`.

--

- `Stack`, like `Pipelines`, except in that learners are trained
  _simultaneously_, so that their predictions can be either combined or
  compared. These are a special kind of learner derived from `Lrnr_base`.

???

- Probably good to point out that cross-validating a `Stack` allows for an
  included `Pipeline` to be subjected to CV in the same way as other learners
  (seriously awesome feature).
- Might be worth mentioning the basic differences between core OOP concepts, for
  example classes, objects, methods, fields, inheritance, etc.
- Because all learners inherit from `Lrnr_base`, they have many features in
  common, and can be used interchangeably.
- All learners define three main methods: `train`, `predict`, and `chain`.
- `Pipeline` allows for covariate screening and model fitting to be subjected to
  the same cross-validation process, necessary for Super Learning.

---

# Object Oriented Programming (OOP)

- The key concept of OOP is that of an object, a collection of data and
  functions that corresponds to some conceptual unit. Objects have two main
  types of elements: _fields_ and _methods_.
  
--

- _fields_ are information about an object.
- _methods_ are actions an object can perform.

--

- Objects are members of _classes_, which define what those specific fields and
  methods are. Classes can inherit elements from other classes.
  
--

- `sl3` is designed using basic OOP principles and the R6 OOP framework, in
  which methods and fields of a class object are accessed using the `$`
  operator.

---
class: inverse, center, middle

# `sl3` in Action

## ain't nothin' like a test drive...

---

# Get the package

- Currently, installation from the `master` branch is the only option:

```{r install_pkg, message=FALSE, eval=FALSE}
if (!("sl3" %in% installed.packages())) {
  devtools::install_github("jeremyrcoyle/sl3")
}
```

```{r prelims-pkgs, message=FALSE, echo=FALSE}
set.seed(49753)
library(data.table)
library(dplyr)
library(origami)
library(SuperLearner)
```

--

- Of course, the package will be available on CRAN. An initial release is
  forthcoming.

--

To start using `sl3`, let's load the package:

```{r prelims-pkg, message=FALSE}
library(sl3)
```

---

# A "toy" data set

We can't do any model fitting without data. We use data from the Collaborative
Perinatal Project (CPP) to illustrate the features of `sl3` as well as its
proper usage. For convenience, the data is included with the `sl3` R package.

```{r prelims-data, message=FALSE}
# load example data set
data(cpp_imputed)

# here are the covariates we are interested in and, of course, the outcome
covars <- c("apgar1", "apgar5", "parity", "gagebrth", "mage", "meducyrs",
            "sexn")
outcome <- "haz"
```

???

- Next, we'll walk through analyzing some data.

---

# Setting up `sl3_Task`s I

Recall that a `sl3_Task` is the core structure that holds the data set and
specifications to be respected in the estimation/modeling procedure.

```{r sl3-task-setup, message=FALSE}
task <- make_sl3_Task(data = cpp_imputed, covariates = covars,
                      outcome = outcome)
```

--

- We use the `make_sl3_Task` method to create a new `sl3_Task`, called `task`.

- Here, we specified the underlying data, `cpp_imputed`, and vectors indicating
  which varaibles to use as covariates and outcomes.

--

- `make_sl3_Task` supports a range of options in order to facilitate the proper
  articulation of more advanced specifics potentially informative of the machine
  learning problem.
  
- For example, we can specify the id, weights, and offset nodes listed
  previously.

---

# Setting up `sl3_Task`s II

Let's take a look at the `task` that we set up:

```{r sl3-task-nodes, message=FALSE}
task
```

---

# Learners

- `Lrnr_base` is the base class for defining machine learning algorithms, as
  well as fits for those algorithms to particular `sl3_Tasks`.

- Different machine learning algorithms are defined in classes that inherit from
  `Lrnr_base` (e.g., the `Lrnr_glm` class inherits from `Lrnr_base`, and defines
  a learner that fits generalized linear models).

- We will use the term learners to refer to the family of classes that inherit
  from `Lrnr_base`.
  
---

Learner objects can be constructed from their class
  definitions using the `make_learner` function:


---

# Screeners, learners, pipelines

Both screeners and learners can be easily instantiated by calling their `new`
methods:

```{r sl3-core-1, message=FALSE}
# a GLM learning algorithm, comes built-in with sl3
glm_learner <- Lrnr_glm$new()
```

--

We can even pull screening and learning algorithms directly from
`Super Learner`:

```{r sl3-core-2, message=FALSE}
# an elastic net screener and learner, accessed via the Super Learner package
slscreener <- Lrnr_pkg_SuperLearner_screener$new("screen.glmnet")
SL.glmnet_learner <- Lrnr_pkg_SuperLearner$new(SL_wrapper = "SL.glmnet")
```

--

And pipelines can be easily created by stringing screeners and learners
together:

```{r sl3-core-3, message=FALSE}
# put them together in a pipeline
screen_and_glm <- Pipeline$new(slscreener, glm_learner)
```

--

Training a learners (or pipelines) is as easy as calling the `train` method:

```{r sl3-core-4, message=FALSE}
# train the pipeline on the data in the task object
sg_fit <- screen_and_glm$train(task)
```

---

# Stacks

We can create stacked regression models (Super Learners) by instantiating a new
stack with several existing learners. (Note that we can even incldue pipelines
in the model stack).

```{r sl3-stacks-1, message=FALSE}
# stacking learners/pipelines is essentially trivial
learner_stack <- Stack$new(SL.glmnet_learner, glm_learner, screen_and_glm)

# train the stacked regression model via its built-in train method
stack_fit <- learner_stack$train(task)
```

--

Let's take a look at the predictions made by the stacked model:

```{r sl3-stacks-2, message=FALSE}
preds <- stack_fit$predict()
head(preds)
```

???

- ...

---

# But What About Cross-Validation?

Almost forgot! CV is necessary in order to honestly evaluate our models and
avoid overfitting. Thus, we need to be able to easily cross-validate the whole
process. We provide facilities for easily doing this, based on the [`origami`
package](https://github.com/jeremyrcoyle/origami).

--

Cross-validating a stacked model is as easy as instantiating and training a new
`Lrnr_cv`. Let's do this with the stacked model we created before

```{r sl3-cv-1, message=FALSE}
cv_stack <- Lrnr_cv$new(learner_stack)
cv_fit <- cv_stack$train(task)
```

---

# Putting it all together: Super Learning

We can build a Super Learner model by combining a cross-validated stacked model
with a meta-learning algorithm.

Let's do this with the cross-validated stack we just created, using a GLM as our
meta-learner:

```{r sl3-cv-sl-1, message=FALSE}
glm_stack <- Pipeline$new(cv_stack, glm_learner)
```

--

Just as in the cases we've already seen, training the Super Learner is an
essentially trivial process:

```{r sl3-cv-sl-2, message=FALSE}
ml_fit <- glm_stack$train(task)
```

--

What do the predictions from our new Super Learner look like?

```{r sl3-cv-sl-3, message=FALSE}
preds_sl <- ml_fit$predict()
head(preds_sl)
```

???

- Worth mentioning that the flexibility offered by our design allows us to
invoke the Super Learner algorithm, but we can also do a lot more...


---
class: inverse, center, middle

# Extending the `sl3` package

---
class: inverse, center, middle

# Computing with `delayed`

---

# ...

```{r sl3-delayed-1, message=FALSE}
metalearner <- make_learner(Lrnr_nnls)
lrnr_glm <- make_learner(Lrnr_glm)
lrnr_rf <- make_learner(Lrnr_randomForest)
lrnr_glmnet <- make_learner(Lrnr_glmnet)
sl <- Lrnr_sl$new(learners = list(lrnr_glm, lrnr_rf, lrnr_glmnet),
                  metalearner = metalearner)
delayed_sl_fit <- delayed_learner_train(sl, task)
```

---

# ...

```{r sl3-delayed-2, message=FALSE}
plot(delayed_sl_fit)
```

---
class: center, middle

# Thanks!

We have a great team: Jeremy Coyle, Nima Hejazi, Ivana Malenica, Oleg Sofrygin.

Slides created via the R package
[**xaringan**](https://github.com/yihui/xaringan).

Powered by [remark.js](https://remarkjs.com),
[**knitr**](http://yihui.name/knitr), and
[R Markdown](https://rmarkdown.rstudio.com).
